using UnityEngine;
using Gameplay.Actions.Effects;
using Gameplay.GameplayObjects.Character;
using System;

namespace Gameplay.Actions.Definitions
{
    /// <summary>
    ///     An action that selects targets within an Area of Effect using a given <see cref="AoETargeting"/> method.
    /// </summary>
    [CreateAssetMenu(menuName = "Actions/AoE Action", order = 4)]
    public class AoETargetingAction : ActionDefinition
    {
        [Header("Targeting")]
        [SerializeReference, SubclassSelector] private AoETargeting _targetingMethod;
        public string RangeString => _targetingMethod.RangeString;

        [Space(10)]
        [SerializeField] private bool _startAoEFromRaycast = false;
        [SerializeField] private float _raycastRange;
        [SerializeField] private LayerMask _raycastLayerMask;

        [SerializeField] private bool _useMaxRangeOnRaycastFailure = false;


        public override bool OnStart(ServerCharacter owner, ref ActionRequestData data) => ActionConclusion.Continue;
        public override bool OnUpdate(ServerCharacter owner, ref ActionRequestData data, float chargePercentage = 1.0f)
        {
            // Determine our desired origin & direction.
            Vector3 actionOrigin = base.GetActionOrigin(ref data);
            Vector3 actionDirection = base.GetActionDirection(ref data);
            DetermineOriginPositionAndDirection(ref actionOrigin, ref actionDirection, _raycastRange);

            // Get our targets & process them.
            _targetingMethod.GetTargets(owner, actionOrigin, actionDirection, chargePercentage, callback: (ServerCharacter owner, ActionHitInformation hitInfo) => ProcessTarget(owner, hitInfo, chargePercentage));

            return ActionConclusion.Continue;
        }

        /// <summary>
        ///     Updates the passed position & direction vectors to be correct for the action's settings.
        /// </summary>
        private void DetermineOriginPositionAndDirection(ref Vector3 originPosition, ref Vector3 originDirection, float maximumDistance)
        {
            if (!_startAoEFromRaycast)
                return; // Our AoE origin should match the action origin.

            if (Physics.Raycast(originPosition, originDirection, out RaycastHit hitInfo, maximumDistance, _raycastLayerMask))
            {
                // We hit something with our raycast. Update our origin & direction with our hit info.
                originPosition = hitInfo.point;
                originDirection = hitInfo.normal;
                return;
            }
            else
            {
                // No hit with our raycast.
                if (_useMaxRangeOnRaycastFailure)
                {
                    // Our AoE origin should be at the maximum distance (Same direction).
                    originPosition = originPosition + originDirection * maximumDistance;
                    return;
                }
                else
                    return; // Our AoE origin should match the action origin.
            }
        }
        /// <summary>
        ///     Process a hit target & apply this action's effects.
        /// </summary>
        private void ProcessTarget(ServerCharacter owner, in ActionHitInformation hitInfo, float chargePercentage)
        {
            // Debug information.
            Debug.DrawRay(hitInfo.HitPoint, hitInfo.HitNormal, Color.red, 1.0f);
            Debug.DrawRay(hitInfo.HitPoint, hitInfo.HitForward, Color.yellow, 1.0f);

            // Perform this action's effects (Damage, Applying Statuses, etc) on the server (Changes are perpetuated to clients).
            for (int i = 0; i < ActionEffects.Length; ++i)
            {
                ActionEffects[i].ApplyEffect(owner, hitInfo, chargePercentage);
            }
        }



        /// <summary>
        ///     Base class for an AoE Targeting Method.
        /// </summary>
        private abstract class AoETargeting
        {
            public abstract string RangeString { get; }

            [SerializeField] protected bool CanTargetOwner;

            [Space(5)]
            [SerializeField] protected bool ScaleRadiusWithChargePercentage;

            [Space(5)]
            [SerializeField] protected bool RequireLineOfSight;
            [SerializeField] protected LayerMask ObstructionsMask;

            [Space(5)]
            [SerializeField] protected LayerMask ValidLayers;



            /// <summary>
            ///     Finds all valid targets and calls the 'callback' function for the ActionHitInformation generated by each.
            /// </summary>
            /// <remarks> The 'HitForward' of the generated ActionHitInformation will always correspond to the target's up.</remarks> // We did it this way for consistency between angles.
            public abstract void GetTargets(ServerCharacter owner, Vector3 origin, Vector3 direction, float chargePercentage, System.Action<ServerCharacter, ActionHitInformation> callback);


            /// <summary>
            ///     Is this target valid given an owner check?
            /// </summary>
            /// <returns> True if the target isn't a child of the owner, OR we're not caring about owner checks. Otherwise, false.</returns>
            protected bool IsValidForOwnerCheck(ServerCharacter owner, Transform potentialTarget) => CanTargetOwner || !potentialTarget.HasParent(owner.transform);
            /// <summary>
            ///     Is this target valid given an obstruction check?
            /// </summary>
            /// <returns> True if the target isn't obstructed, OR if we're not caring about obstruction checks. Otherwise, false</returns>
            protected bool IsValidForObstructionCheck(in Vector3 origin, Transform potentialTarget, in Vector3 hitPoint)
            {
                if (!RequireLineOfSight || !Physics.Linecast(origin, hitPoint, out RaycastHit hitInfo, ObstructionsMask, QueryTriggerInteraction.Ignore))
                    return true;    // We aren't caring about obstruction checks OR we didn't find any obstructions.

                if (hitInfo.transform == potentialTarget)
                    return true;    // The discovered obstruction was the target, so no obstructions are between them and the origin.

                return false;   // Obstructed by something other than the target.
            }
        }
        /// <summary>
        ///     AoE Targeting Method using a Sphere.
        /// </summary>
        [System.Serializable]
        private class SphereAoETargeting : AoETargeting
        {
            public override string RangeString => _sphereRadius + Units.DISTANCE_UNITS + " Sphere";

            [SerializeField] private float _sphereRadius;

            public override void GetTargets(ServerCharacter owner, Vector3 origin, Vector3 direction, float chargePercentage, System.Action<ServerCharacter, ActionHitInformation> callback)
            {
                float radius = ScaleRadiusWithChargePercentage ? _sphereRadius * chargePercentage : _sphereRadius;
                foreach(Collider potentialTarget in Physics.OverlapSphere(origin, radius, ValidLayers, QueryTriggerInteraction.Ignore))
                {
                    if (!IsValidForOwnerCheck(owner, potentialTarget.transform))
                        continue;

                    Vector3 hitPoint = potentialTarget.ClosestPoint(origin);
                    if (!IsValidForObstructionCheck(origin, potentialTarget.transform, hitPoint))
                        continue;

                    Vector3 hitNormal = (owner.transform.position - hitPoint).normalized;
                    Vector3 hitForward = owner.transform.up;

                    //yield return potentialTarget.transform;
                    callback?.Invoke(owner, new ActionHitInformation(potentialTarget.transform, hitPoint, hitNormal, hitForward));
                }
            }
        }
        /// <summary>
        ///     AoE Targeting Method using a line/capsule with the desired thickness/radius.
        /// </summary>
        [System.Serializable]
        private class LineAoETargeting : AoETargeting
        {
            public override string RangeString => _lineLength + Units.DISTANCE_UNITS + " Long " + _lineRadius + Units.DISTANCE_UNITS + " Wide Line";

            [SerializeField] private float _lineLength;
            [SerializeField] private float _lineRadius;

            public override void GetTargets(ServerCharacter owner, Vector3 origin, Vector3 direction, float chargePercentage, Action<ServerCharacter, ActionHitInformation> callback)
            {
                // Thick Raycast (Spherecast).
                float length = ScaleRadiusWithChargePercentage ? _lineLength * chargePercentage : _lineLength;
                float radius = ScaleRadiusWithChargePercentage ? _lineRadius * chargePercentage : _lineRadius;
                foreach (RaycastHit potentialTarget in Physics.SphereCastAll(origin, length, direction, radius, ValidLayers, QueryTriggerInteraction.Ignore))
                {
                    Vector3 hitPoint = potentialTarget.point;
                    Vector3 hitNormal = potentialTarget.normal;

                    if (hitPoint == Vector3.zero && hitNormal == -direction)
                    {
                        // The collider was overlapping with the spherecast when it started, so has invalid 'point' and 'normal' data.
                        // Recalculate the invalid data.
                        hitPoint = potentialTarget.collider.ClosestPoint(origin);
                        hitNormal = (origin - hitPoint).normalized;
                    }

                    if (!IsValidForOwnerCheck(owner, potentialTarget.transform) || !IsValidForObstructionCheck(origin, potentialTarget.transform, hitPoint))
                        continue;   // This target is invalid. Don't process it.

                    callback?.Invoke(owner, new ActionHitInformation(potentialTarget.transform, hitPoint, hitNormal, potentialTarget.transform.up));
                }
            }
        }
        /// <summary>
        ///     AoE Targeting Method using a Cone.
        /// </summary>
        // Note: Effectively a Sphere but discarding targets outwith specified Angle.
        [System.Serializable]
        private class ConeAoETargeting : AoETargeting
        {
            public override string RangeString => _coneLength + Units.DISTANCE_UNITS + " Long " + _coneAngle + Units.DEGREES_UNITS + " Angle Cone";
            [SerializeField] private float _coneLength;
            [SerializeField] private float _coneAngle;

            public override void GetTargets(ServerCharacter owner, Vector3 origin, Vector3 direction, float chargePercentage, Action<ServerCharacter, ActionHitInformation> callback)
            {
                // OverlapSphere with Angle Check.
                float coneLength = ScaleRadiusWithChargePercentage ? _coneLength * chargePercentage : _coneLength;
                float halfAngle = ((ScaleRadiusWithChargePercentage ? _coneAngle * chargePercentage : _coneAngle) / 2.0f);
                foreach (Collider potentialTarget in Physics.OverlapSphere(origin, coneLength, ValidLayers, QueryTriggerInteraction.Ignore))
                {
                    if (!IsValidForOwnerCheck(owner, potentialTarget.transform))
                        continue;

                    // Angle Check (Makes it a cone rather than a sphere).
                    if (Vector3.Angle(direction, (potentialTarget.transform.position - origin).normalized) > halfAngle)
                        continue;

                    Vector3 hitPoint = potentialTarget.ClosestPoint(origin);
                    if (!IsValidForObstructionCheck(origin, potentialTarget.transform, hitPoint))
                        continue;

                    Vector3 hitNormal = (owner.transform.position - hitPoint).normalized;
                    Vector3 hitForward = owner.transform.up;

                    //yield return potentialTarget.transform;
                    callback?.Invoke(owner, new ActionHitInformation(potentialTarget.transform, hitPoint, hitNormal, hitForward));
                }
            }
        }
    }
}